<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbital Mechanics Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(to bottom, #000000, #0a0a1a);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 30, 0.85);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            max-width: 320px;
            z-index: 1000;
        }

        h1 {
            font-size: 20px;
            margin-bottom: 15px;
            color: #6eb5ff;
            text-shadow: 0 0 10px rgba(110, 181, 255, 0.5);
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #a8c5e6;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(100, 150, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6eb5ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(110, 181, 255, 0.8);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6eb5ff;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(110, 181, 255, 0.8);
        }

        .value-display {
            display: inline-block;
            float: right;
            color: #6eb5ff;
            font-weight: bold;
            font-size: 12px;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        .clear-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }

        .clear-btn:hover {
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
        }

        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 10, 30, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            font-size: 11px;
            color: #a8c5e6;
            max-width: 320px;
        }

        .info strong {
            color: #6eb5ff;
        }

        .launch-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: none;
            z-index: 2000;
            pointer-events: none;
        }

        .launch-mode.active {
            display: flex;
        }

        .launch-instruction {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 30, 0.9);
            padding: 12px 24px;
            border-radius: 8px;
            border: 1px solid #6eb5ff;
            font-size: 13px;
            color: #6eb5ff;
            text-align: center;
            box-shadow: 0 0 20px rgba(110, 181, 255, 0.4);
            white-space: nowrap;
        }

        .launch-instruction strong {
            color: #fff;
        }

        .satellite-count {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 30, 0.85);
            padding: 15px 25px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            font-size: 18px;
            color: #6eb5ff;
            font-weight: bold;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .satellite-info {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(10, 10, 30, 0.9);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            font-size: 12px;
            color: #a8c5e6;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            min-width: 250px;
            display: none;
        }

        .satellite-info.visible {
            display: block;
        }

        .satellite-info .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
        }

        .satellite-info .stat-label {
            color: #6eb5ff;
            font-weight: bold;
        }

        .satellite-info .stat-value {
            color: #ffffff;
        }

        .satellite-info .status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 1px;
        }

        .satellite-info .status.stable {
            background: rgba(46, 213, 115, 0.2);
            color: #2ed573;
            border: 1px solid #2ed573;
        }

        .satellite-info .status.decaying {
            background: rgba(255, 159, 64, 0.2);
            color: #ff9f40;
            border: 1px solid #ff9f40;
        }

        .satellite-info .status.escape {
            background: rgba(238, 82, 83, 0.2);
            color: #ee5253;
            border: 1px solid #ee5253;
        }

        .time-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 10, 30, 0.85);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .time-btn {
            width: 40px;
            height: 40px;
            padding: 0;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .time-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .time-btn:active {
            transform: translateY(0);
        }

        .time-btn.paused {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .satellite-type-selector {
            margin-top: 10px;
            display: flex;
            gap: 5px;
        }

        .type-option {
            flex: 1;
            padding: 8px;
            background: rgba(100, 150, 255, 0.1);
            border: 2px solid rgba(100, 150, 255, 0.3);
            border-radius: 6px;
            color: #a8c5e6;
            font-size: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .type-option:hover {
            background: rgba(100, 150, 255, 0.2);
            border-color: rgba(100, 150, 255, 0.5);
        }

        .type-option.selected {
            background: rgba(110, 181, 255, 0.3);
            border-color: #6eb5ff;
            color: #6eb5ff;
            font-weight: bold;
        }

        .color-options {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .color-option:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px currentColor;
        }

        .color-option.selected {
            border-color: white;
            box-shadow: 0 0 20px currentColor;
        }

        .mission-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 30, 0.95);
            padding: 20px 30px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.5);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
            min-width: 400px;
            z-index: 1000;
            text-align: center;
            transition: opacity 0.3s, transform 0.3s;
        }

        .mission-panel.hidden {
            display: none;
        }

        .mission-toggle-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #ffffff;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
        }

        .mission-toggle-btn:hover {
            background: rgba(255, 100, 100, 0.3);
            border-color: rgba(255, 100, 100, 0.6);
            transform: scale(1.1);
        }

        .mission-title {
            font-size: 14px;
            color: #ffd700;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .mission-description {
            font-size: 16px;
            color: #ffffff;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .mission-objectives {
            text-align: left;
            margin: 15px 0;
        }

        .mission-objective {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            color: #a8c5e6;
            font-size: 13px;
        }

        .objective-checkbox {
            width: 18px;
            height: 18px;
            border: 2px solid #6eb5ff;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .objective-checkbox.completed {
            background: #2ed573;
            border-color: #2ed573;
        }

        .objective-checkbox.completed::after {
            content: '‚úì';
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .mission-progress {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(100, 150, 255, 0.3);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(100, 150, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .mission-complete {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-color: #f5576c;
            animation: missionPulse 1s ease-in-out;
        }

        @keyframes missionPulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }

        .next-mission-btn {
            margin-top: 15px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            border: none;
            border-radius: 8px;
            color: #0a0a1a;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 12px;
        }

        .next-mission-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="mission-panel" id="missionPanel">
        <button class="mission-toggle-btn" id="missionToggleBtn" title="Hide Missions">‚úï</button>
        <div class="mission-title" id="missionTitle">Mission 1: First Launch</div>
        <div class="mission-description" id="missionDescription">Launch your first satellite into orbit</div>
        <div class="mission-objectives" id="missionObjectives">
            <!-- Objectives will be inserted here -->
        </div>
        <div class="mission-progress">
            <div style="font-size: 12px; color: #a8c5e6; margin-bottom: 5px;">
                Progress: <span id="missionProgressText">0/1</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </div>
        <button class="next-mission-btn" id="nextMissionBtn" style="display: none;">Next Mission ‚Üí</button>
    </div>

    <div class="controls">
        <h1>üõ∞Ô∏è Orbital Simulator</h1>
        
        <div class="control-group">
            <label>Satellite Size <span class="value-display" id="sizeValue">5</span></label>
            <input type="range" id="sizeSlider" min="2" max="15" value="5" step="0.5">
        </div>

        <div class="control-group">
            <label>Orbital Height <span class="value-display" id="heightValue">150</span></label>
            <input type="range" id="heightSlider" min="80" max="400" value="150" step="5">
        </div>

        <div class="control-group">
            <label>Simulation Speed <span class="value-display" id="speedValue">1.0x</span></label>
            <input type="range" id="speedSlider" min="0.1" max="100" value="1" step="0.5">
        </div>

        <div class="control-group">
            <label>Satellite Type</label>
            <div class="satellite-type-selector">
                <div class="type-option selected" data-type="standard">Standard</div>
                <div class="type-option" data-type="probe">Probe</div>
                <div class="type-option" data-type="station">Station</div>
                <div class="type-option" data-type="debris">Debris</div>
            </div>
        </div>

        <div class="control-group">
            <label>Satellite Color</label>
            <div class="color-options">
                <div class="color-option selected" style="background: #6eb5ff;" data-color="#6eb5ff"></div>
                <div class="color-option" style="background: #ff6eb5;" data-color="#ff6eb5"></div>
                <div class="color-option" style="background: #6effb5;" data-color="#6effb5"></div>
                <div class="color-option" style="background: #ffb56e;" data-color="#ffb56e"></div>
                <div class="color-option" style="background: #b56eff;" data-color="#b56eff"></div>
            </div>
        </div>

        <button id="addSatellite">Launch Satellite</button>
        <button id="addGeoSync" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); box-shadow: 0 4px 15px rgba(17, 153, 142, 0.4);">Launch Geosynchronous</button>
        <button id="toggleGuides" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);">Hide 3D Guides</button>
        <button id="showMissionsBtn" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4); display: none;">Show Missions</button>
        <button id="toggleMoon" style="background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%); box-shadow: 0 4px 15px rgba(253, 203, 110, 0.4);">Add Moon üåô</button>
        <button class="clear-btn" id="clearAll">Clear All Satellites</button>
    </div>

    <div class="satellite-count">
        Satellites: <span id="count">0</span>
    </div>

    <div class="satellite-info" id="satelliteInfo">
        <div class="stat-row">
            <span class="stat-label">Altitude:</span>
            <span class="stat-value" id="infoAltitude">--</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Velocity:</span>
            <span class="stat-value" id="infoVelocity">--</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Period:</span>
            <span class="stat-value" id="infoPeriod">--</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Eccentricity:</span>
            <span class="stat-value" id="infoEccentricity">--</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Type:</span>
            <span class="stat-value" id="infoType">--</span>
        </div>
        <div class="status stable" id="infoStatus">STABLE ORBIT</div>
    </div>

    <div class="time-controls">
        <button class="time-btn" id="stepBackward" title="Step Backward">‚óÑ</button>
        <button class="time-btn" id="playPause" title="Pause/Play">‚ùö‚ùö</button>
        <button class="time-btn" id="stepForward" title="Step Forward">‚ñ∫</button>
    </div>

    <div class="launch-mode" id="launchMode">
        <div class="launch-instruction">
            üéØ <strong>LAUNCH MODE:</strong> Click where you want satellite ‚Ä¢ Drag to set velocity ‚Ä¢ Blue line shows predicted orbit ‚Ä¢ <strong>Red</strong> = apoapsis, <strong>Green</strong> = periapsis ‚Ä¢ <strong>ESC</strong> to cancel
        </div>
    </div>

    <div class="info">
        <strong>Controls:</strong><br>
        ‚Ä¢ Click & drag anywhere to rotate view<br>
        ‚Ä¢ Right-click drag also rotates view<br>
        ‚Ä¢ Scroll to zoom in/out<br>
        <br>
        <strong>Launch Mode Tips:</strong><br>
        ‚Ä¢ Drag <strong>horizontally</strong> = orbital motion<br>
        ‚Ä¢ Drag <strong>up/down</strong> = vertical velocity<br>
        ‚Ä¢ <strong>Diagonal</strong> = combined motion<br>
        ‚Ä¢ Blue line shows predicted elliptical orbit<br>
        ‚Ä¢ Red/green markers show apoapsis/periapsis<br>
        <br>
        <strong>Physics:</strong> Real orbital mechanics! See your exact trajectory before launch. Geosynchronous satellites maintain orbital period. Try circular, elliptical, or crash-course orbits!
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        camera.position.set(0, 200, 500);
        camera.lookAt(0, 0, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1.5, 2000);
        pointLight.position.set(200, 200, 200);
        scene.add(pointLight);

        const planetLight = new THREE.PointLight(0x6eb5ff, 0.5, 500);
        scene.add(planetLight);

        // Create stars
        const starsGeometry = new THREE.BufferGeometry();

        // Create a circular texture for the stars
        const starsCanvas = document.createElement('canvas');
        starsCanvas.width = 32;
        starsCanvas.height = 32;
        const starsCtx = starsCanvas.getContext('2d');
        const gradient = starsCtx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        starsCtx.fillStyle = gradient;
        starsCtx.fillRect(0, 0, 32, 32);
        const starsTexture = new THREE.CanvasTexture(starsCanvas);

        const starsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 2,
            transparent: true,
            map: starsTexture,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const starsVertices = [];
        for (let i = 0; i < 3000; i++) {
            const x = (Math.random() - 0.5) * 4000;
            const y = (Math.random() - 0.5) * 4000;
            const z = (Math.random() - 0.5) * 4000;
            starsVertices.push(x, y, z);
        }

        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Create planet with detailed surface
        const planetRadius = 50;
        const planetGeometry = new THREE.SphereGeometry(planetRadius, 256, 256);
        
        // Create detailed planet material with procedural textures
        const planetMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                varying vec2 vUv;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vNormal;
                varying vec3 vPosition;
                varying vec2 vUv;

                // Improved noise functions
                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
                }

                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);

                    float a = hash(i);
                    float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0));
                    float d = hash(i + vec2(1.0, 1.0));

                    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
                }

                float fbm(vec2 p) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    for(int i = 0; i < 6; i++) {
                        value += amplitude * noise(p);
                        p *= 2.0;
                        amplitude *= 0.5;
                    }
                    return value;
                }

                // Ridged noise for mountains
                float ridgedNoise(vec2 p) {
                    return 1.0 - abs(noise(p) * 2.0 - 1.0);
                }

                float ridgedFbm(vec2 p) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    for(int i = 0; i < 4; i++) {
                        value += amplitude * ridgedNoise(p);
                        p *= 2.5;
                        amplitude *= 0.4;
                    }
                    return value;
                }

                void main() {
                    vec2 uv = vUv * 4.0;

                    // Large-scale continent shapes
                    float continentNoise = fbm(uv * 0.8 + vec2(time * 0.01, 0.0));

                    // Add tectonic plate-like features
                    float tectonicNoise = fbm(uv * 0.3 + vec2(15.0, 7.0));

                    // Elevation map with mountains
                    float elevation = fbm(uv * 2.0);
                    float mountains = ridgedFbm(uv * 4.0) * 0.6;

                    // Combine for terrain height
                    float terrainHeight = continentNoise + mountains * 0.3;

                    // Water levels - deeper oceans, shallow coasts
                    float waterLevel = 0.45;
                    float landMask = smoothstep(waterLevel - 0.02, waterLevel + 0.02, terrainHeight);

                    // Ocean colors - deep to shallow
                    vec3 deepOcean = vec3(0.02, 0.05, 0.15);
                    vec3 shallowOcean = vec3(0.1, 0.3, 0.5);
                    float oceanDepth = (waterLevel - terrainHeight) / waterLevel;
                    vec3 oceanColor = mix(shallowOcean, deepOcean, smoothstep(0.0, 1.0, oceanDepth));

                    // Land elevation colors
                    vec3 beachColor = vec3(0.76, 0.70, 0.50);    // Sand
                    vec3 grassColor = vec3(0.2, 0.5, 0.2);       // Lowland grass
                    vec3 forestColor = vec3(0.1, 0.3, 0.1);      // Dense forest
                    vec3 rockColor = vec3(0.4, 0.35, 0.3);       // Mountain rock
                    vec3 snowColor = vec3(0.9, 0.92, 0.95);      // Mountain peaks

                    // Calculate land elevation above sea level
                    float landElevation = (terrainHeight - waterLevel) / (1.0 - waterLevel);

                    // Terrain type based on elevation and noise
                    vec3 landColor;
                    if (landElevation < 0.08) {
                        // Beach/coast
                        landColor = beachColor;
                    } else if (landElevation < 0.3) {
                        // Grassland
                        landColor = mix(grassColor, forestColor, fbm(uv * 8.0));
                    } else if (landElevation < 0.6) {
                        // Forest/hills
                        float forestVariation = noise(uv * 6.0);
                        landColor = mix(forestColor, grassColor, forestVariation * 0.3);
                    } else if (landElevation < 0.8) {
                        // Mountains
                        float rockVariation = fbm(uv * 10.0);
                        landColor = mix(rockColor, forestColor, rockVariation * 0.4);
                    } else {
                        // Snow-capped peaks
                        float snowMix = smoothstep(0.75, 0.9, landElevation);
                        landColor = mix(rockColor, snowColor, snowMix);
                    }

                    // Add desert regions (based on latitude and tectonic)
                    float desertMask = smoothstep(0.3, 0.5, abs(vUv.y - 0.5)) *
                                      smoothstep(0.4, 0.6, tectonicNoise);
                    vec3 desertColor = vec3(0.8, 0.65, 0.4);
                    landColor = mix(landColor, desertColor, desertMask * landMask * 0.7);

                    // Base color
                    vec3 baseColor = mix(oceanColor, landColor, landMask);

                    // Polar ice caps
                    float polarFactor = abs(vUv.y - 0.5) * 2.0;
                    float iceMask = smoothstep(0.82, 0.96, polarFactor);
                    vec3 polarIce = vec3(0.95, 0.97, 1.0);
                    baseColor = mix(baseColor, polarIce, iceMask);

                    // Add fine detail variation
                    float microDetail = fbm(uv * 16.0) * 0.05;
                    baseColor += microDetail;

                    // Enhanced ocean specular highlights
                    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                    float oceanSpecular = pow(max(dot(vNormal, lightDir), 0.0), 40.0) *
                                         (1.0 - landMask) * 0.8;
                    baseColor += vec3(1.0, 1.0, 1.0) * oceanSpecular;

                    // Subsurface scattering for shallow water
                    float sss = (1.0 - landMask) * landMask * 0.3;
                    baseColor += vec3(0.1, 0.4, 0.5) * sss;

                    // Atmospheric rim lighting
                    float rimIntensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                    vec3 atmosphereGlow = vec3(0.3, 0.5, 0.9) * rimIntensity * 0.4;

                    // Day/night terminator (subtle)
                    float dayNight = dot(vNormal, lightDir) * 0.5 + 0.5;
                    baseColor *= 0.3 + dayNight * 0.7;

                    gl_FragColor = vec4(baseColor + atmosphereGlow, 1.0);
                }
            `
        });
        
        const planet = new THREE.Mesh(planetGeometry, planetMaterial);
        scene.add(planet);

        // Add cloud layer
        const cloudGeometry = new THREE.SphereGeometry(planetRadius * 1.01, 64, 64);
        const cloudMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vNormal;
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                varying vec3 vNormal;
                
                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
                }
                
                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    float a = hash(i);
                    float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0));
                    float d = hash(i + vec2(1.0, 1.0));
                    
                    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
                }
                
                float fbm(vec2 p) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    for(int i = 0; i < 4; i++) {
                        value += amplitude * noise(p);
                        p *= 2.0;
                        amplitude *= 0.5;
                    }
                    return value;
                }
                
                void main() {
                    // Animated clouds
                    vec2 uv = vUv * 6.0 + vec2(time * 0.02, 0.0);
                    float cloudPattern = fbm(uv);
                    
                    // Make clouds wispy
                    float clouds = smoothstep(0.4, 0.7, cloudPattern);
                    
                    // Fade at edges
                    float edgeFade = pow(dot(vNormal, vec3(0.0, 0.0, 1.0)), 0.5);
                    clouds *= edgeFade;
                    
                    gl_FragColor = vec4(1.0, 1.0, 1.0, clouds * 0.4);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        
        const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
        scene.add(clouds);

        // Store reference for animation
        const cloudMaterial_ref = cloudMaterial;

        // Add atmosphere glow
        const atmosphereGeometry = new THREE.SphereGeometry(planetRadius * 1.15, 64, 64);
        const atmosphereMaterial = new THREE.ShaderMaterial({
            uniforms: {},
            vertexShader: `
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vNormal;
                void main() {
                    float intensity = pow(0.5 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                    gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
                }
            `,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            transparent: true
        });
        
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        scene.add(atmosphere);

        // Add reference grid to help visualize 3D space
        const gridHelper = new THREE.GridHelper(400, 20, 0x444444, 0x222222);
        gridHelper.material.transparent = true;
        gridHelper.material.opacity = 0.3;
        scene.add(gridHelper);

        // Add orbital plane reference circle
        const orbitRingGeometry = new THREE.TorusGeometry(150, 0.5, 8, 64);
        const orbitRingMaterial = new THREE.MeshBasicMaterial({
            color: 0x4488ff,
            transparent: true,
            opacity: 0.2
        });
        const orbitRing = new THREE.Mesh(orbitRingGeometry, orbitRingMaterial);
        orbitRing.rotation.x = Math.PI / 2;
        scene.add(orbitRing);

        // Add axis helpers for spatial reference
        const axisLength = 200;
        const xAxis = new THREE.ArrowHelper(
            new THREE.Vector3(1, 0, 0),
            new THREE.Vector3(0, 0, 0),
            axisLength,
            0xff4444,
            20,
            10
        );
        xAxis.line.material.transparent = true;
        xAxis.line.material.opacity = 0.3;
        xAxis.cone.material.transparent = true;
        xAxis.cone.material.opacity = 0.3;
        scene.add(xAxis);

        const yAxis = new THREE.ArrowHelper(
            new THREE.Vector3(0, 1, 0),
            new THREE.Vector3(0, 0, 0),
            axisLength,
            0x44ff44,
            20,
            10
        );
        yAxis.line.material.transparent = true;
        yAxis.line.material.opacity = 0.3;
        yAxis.cone.material.transparent = true;
        yAxis.cone.material.opacity = 0.3;
        scene.add(yAxis);

        const zAxis = new THREE.ArrowHelper(
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(0, 0, 0),
            axisLength,
            0x4444ff,
            20,
            10
        );
        zAxis.line.material.transparent = true;
        zAxis.line.material.opacity = 0.3;
        zAxis.cone.material.transparent = true;
        zAxis.cone.material.opacity = 0.3;
        scene.add(zAxis);

        // Satellites array
        const satellites = [];
        const explosions = [];
        const G = 100; // Gravitational constant (scaled for visualization)
        const planetMass = 1000;

        // Moon parameters
        const moonMass = 400; // 0.4 √ó planet mass
        const moonDistance = 2000; // Distance from planet
        const moonRadius = 35; // Visual size (larger so it's visible at distance)
        let moonEnabled = false;
        let moonPosition = new THREE.Vector3(moonDistance, 0, 0);
        let moonVelocity = new THREE.Vector3(0, 0, Math.sqrt((G * planetMass) / moonDistance));

        // Create moon
        const moonGeometry = new THREE.SphereGeometry(moonRadius, 64, 64);
        const moonMaterial = new THREE.MeshStandardMaterial({
            color: 0xaaaaaa,
            roughness: 0.9,
            metalness: 0.1,
            emissive: 0x444444,
            emissiveIntensity: 0.3
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.copy(moonPosition);
        moon.visible = false; // Hidden by default
        scene.add(moon);

        // Moon label (to help locate it)
        const moonLabelCanvas = document.createElement('canvas');
        moonLabelCanvas.width = 128;
        moonLabelCanvas.height = 64;
        const moonLabelCtx = moonLabelCanvas.getContext('2d');
        moonLabelCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        moonLabelCtx.font = 'bold 32px Arial';
        moonLabelCtx.textAlign = 'center';
        moonLabelCtx.fillText('üåô', 64, 45);
        const moonLabelTexture = new THREE.CanvasTexture(moonLabelCanvas);
        const moonLabelMaterial = new THREE.SpriteMaterial({
            map: moonLabelTexture,
            transparent: true
        });
        const moonLabel = new THREE.Sprite(moonLabelMaterial);
        moonLabel.scale.set(100, 50, 1);
        moonLabel.position.set(0, moonRadius + 60, 0);
        moonLabel.visible = false;
        moon.add(moonLabel);

        // Moon orbit trail
        const moonTrailGeometry = new THREE.BufferGeometry();
        const moonTrailMaterial = new THREE.LineBasicMaterial({
            color: 0x888888,
            transparent: true,
            opacity: 0.3,
            linewidth: 1
        });
        const moonTrail = new THREE.Line(moonTrailGeometry, moonTrailMaterial);
        const moonTrailPositions = [];
        const maxMoonTrailLength = 200;
        moonTrail.visible = false;
        scene.add(moonTrail);

        // Moon orbit reference ring (shows the orbital path)
        const moonOrbitRingGeometry = new THREE.RingGeometry(moonDistance - 5, moonDistance + 5, 128);
        const moonOrbitRingMaterial = new THREE.MeshBasicMaterial({
            color: 0xffaa00,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.2
        });
        const moonOrbitRing = new THREE.Mesh(moonOrbitRingGeometry, moonOrbitRingMaterial);
        moonOrbitRing.rotation.x = Math.PI / 2; // Rotate to horizontal plane
        moonOrbitRing.visible = false;
        scene.add(moonOrbitRing);

        // Selected color and type
        let selectedColor = '#6eb5ff';
        let selectedType = 'standard';

        // Time control state
        let isPaused = false;
        let hoveredSatellite = null;

        // Launch mode state
        let launchMode = false;
        let launchStartPos = null;
        let launchCurrentPos = null;
        let previewSatellite = null;
        let velocityArrow = null;
        let predictedOrbitLine = null;
        let apoapsisMarker = null;
        let periapsisMarker = null;

        // Mission System
        const missions = [
            {
                id: 1,
                title: "Mission 1: First Launch",
                description: "Launch your first satellite into orbit",
                objectives: [
                    { id: "launch", text: "Launch a satellite", check: () => satellites.length > 0 }
                ]
            },
            {
                id: 2,
                title: "Mission 2: Stable Orbit",
                description: "Achieve a circular orbit with low eccentricity",
                objectives: [
                    { id: "circular", text: "Create orbit with eccentricity < 0.1", check: () => {
                        return satellites.some(sat => {
                            const orbit = calculateOrbitFromState(sat.mesh.position, sat.velocity);
                            return orbit.eccentricity < 0.1 && orbit.eccentricity >= 0;
                        });
                    }}
                ]
            },
            {
                id: 3,
                title: "Mission 3: High Orbit",
                description: "Launch a satellite above 200 units altitude",
                objectives: [
                    { id: "highOrbit", text: "Achieve altitude > 200 units", check: () => {
                        return satellites.some(sat => sat.mesh.position.length() - planetRadius > 200);
                    }}
                ]
            },
            {
                id: 4,
                title: "Mission 4: Constellation",
                description: "Create a satellite constellation",
                objectives: [
                    { id: "three", text: "Have 3 satellites in orbit simultaneously", check: () => satellites.length >= 3 }
                ]
            },
            {
                id: 5,
                title: "Mission 5: Elliptical Orbit",
                description: "Create an elliptical orbit with moderate eccentricity",
                objectives: [
                    { id: "elliptical", text: "Create orbit with 0.3 < eccentricity < 0.7", check: () => {
                        return satellites.some(sat => {
                            const orbit = calculateOrbitFromState(sat.mesh.position, sat.velocity);
                            return orbit.eccentricity > 0.3 && orbit.eccentricity < 0.7;
                        });
                    }}
                ]
            },
            {
                id: 6,
                title: "Mission 6: Polar Coverage",
                description: "Launch satellites for global coverage",
                objectives: [
                    { id: "polarSats", text: "Have 5 satellites in orbit", check: () => satellites.length >= 5 }
                ]
            },
            {
                id: 7,
                title: "Mission 7: Mixed Fleet",
                description: "Launch different types of satellites",
                objectives: [
                    { id: "standard", text: "Launch a standard satellite", check: () => launchedTypes.has('standard') },
                    { id: "probe", text: "Launch a probe", check: () => launchedTypes.has('probe') },
                    { id: "station", text: "Launch a station", check: () => launchedTypes.has('station') }
                ]
            },
            {
                id: 8,
                title: "Mission 8: Geostationary Network",
                description: "Create a geostationary satellite network",
                objectives: [
                    { id: "geoSync", text: "Launch 3 geosynchronous satellites", check: () => {
                        return satellites.filter(sat => sat.isGeosync).length >= 3;
                    }}
                ]
            }
        ];

        let currentMissionIndex = 0;
        let completedObjectives = new Set();
        let missionCompleted = false;
        let launchedTypes = new Set();

        // Load a mission by index
        function loadMission(index) {
            if (index >= missions.length) {
                // All missions completed!
                document.getElementById('missionTitle').textContent = "üéâ All Missions Complete!";
                document.getElementById('missionDescription').textContent = "Congratulations! You've mastered orbital mechanics.";
                document.getElementById('missionObjectives').innerHTML = '<div style="text-align: center; padding: 20px; color: #ffd700;">You are now a certified orbital engineer!</div>';
                document.getElementById('nextMissionBtn').style.display = 'none';
                document.querySelector('.mission-progress').style.display = 'none';
                return;
            }

            currentMissionIndex = index;
            const mission = missions[index];
            completedObjectives.clear();
            missionCompleted = false;

            // Update mission info
            document.getElementById('missionTitle').textContent = mission.title;
            document.getElementById('missionDescription').textContent = mission.description;

            // Create objectives list
            const objectivesContainer = document.getElementById('missionObjectives');
            objectivesContainer.innerHTML = '';
            mission.objectives.forEach(obj => {
                const objDiv = document.createElement('div');
                objDiv.className = 'objective';
                objDiv.id = `objective-${obj.id}`;
                objDiv.innerHTML = `
                    <span class="objective-checkbox">‚òê</span>
                    <span class="objective-text">${obj.text}</span>
                `;
                objectivesContainer.appendChild(objDiv);
            });

            // Reset progress bar
            document.getElementById('missionProgressText').textContent = `0/${mission.objectives.length}`;
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('nextMissionBtn').style.display = 'none';
            document.getElementById('missionPanel').classList.remove('mission-complete');
        }

        // Update mission progress each frame
        function updateMission() {
            if (missionCompleted || currentMissionIndex >= missions.length) return;

            const mission = missions[currentMissionIndex];
            let completedCount = 0;

            // Check each objective
            mission.objectives.forEach(obj => {
                const isComplete = obj.check();
                const objElement = document.getElementById(`objective-${obj.id}`);

                if (isComplete && !completedObjectives.has(obj.id)) {
                    completedObjectives.add(obj.id);
                    if (objElement) {
                        objElement.classList.add('complete');
                        objElement.querySelector('.objective-checkbox').textContent = '‚òë';
                    }
                }

                if (completedObjectives.has(obj.id)) {
                    completedCount++;
                }
            });

            // Update progress bar
            const progress = (completedCount / mission.objectives.length) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
            document.getElementById('missionProgressText').textContent = `${completedCount}/${mission.objectives.length}`;

            // Check if mission is complete
            if (completedCount === mission.objectives.length && !missionCompleted) {
                missionCompleted = true;
                document.getElementById('missionPanel').classList.add('mission-complete');
                document.getElementById('nextMissionBtn').style.display = 'block';
            }
        }

        // Create velocity arrow visualization
        function createVelocityArrow() {
            const group = new THREE.Group();
            
            // Arrow shaft - thicker for better visibility
            const shaftGeometry = new THREE.CylinderGeometry(1.5, 1.5, 1, 8);
            const shaftMaterial = new THREE.MeshBasicMaterial({ 
                color: selectedColor,
                transparent: true,
                opacity: 0.9
            });
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
            
            // Arrow head - larger
            const headGeometry = new THREE.ConeGeometry(4, 8, 8);
            const headMaterial = new THREE.MeshBasicMaterial({ 
                color: selectedColor,
                transparent: true,
                opacity: 0.9
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            
            // Add a pulsing sphere at the tip to show velocity magnitude
            const tipGeometry = new THREE.SphereGeometry(3, 16, 16);
            const tipMaterial = new THREE.MeshBasicMaterial({
                color: selectedColor,
                transparent: true,
                opacity: 0.7
            });
            const tip = new THREE.Mesh(tipGeometry, tipMaterial);
            
            group.add(shaft);
            group.add(head);
            group.add(tip);
            group.visible = false;
            scene.add(group);
            
            return { group, shaft, head, tip, material: shaftMaterial, headMaterial, tipMaterial };
        }

        velocityArrow = createVelocityArrow();

        // Helper function to thoroughly dispose of a Three.js object
        function disposeObject(obj) {
            if (!obj) return;

            // Recursively dispose children first
            while(obj.children && obj.children.length > 0) {
                disposeObject(obj.children[0]);
                obj.remove(obj.children[0]);
            }

            // Dispose geometry
            if (obj.geometry) {
                obj.geometry.dispose();
            }

            // Dispose material(s)
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(mat => {
                        if (mat.map) mat.map.dispose();
                        mat.dispose();
                    });
                } else {
                    if (obj.material.map) obj.material.map.dispose();
                    obj.material.dispose();
                }
            }

            // Remove from parent
            if (obj.parent) {
                obj.parent.remove(obj);
            }
        }

        // Orbital mechanics calculations
        function calculateOrbitFromState(position, velocity) {
            const r = position.length();
            const v = velocity.length();
            const vr = position.dot(velocity) / r; // Radial velocity component

            // Specific orbital energy
            const specificEnergy = (v * v) / 2 - (G * planetMass) / r;

            // Semi-major axis
            const a = -(G * planetMass) / (2 * specificEnergy);

            // Eccentricity vector
            const eVec = new THREE.Vector3()
                .copy(velocity)
                .cross(position.clone().cross(velocity))
                .divideScalar(G * planetMass)
                .sub(position.clone().normalize());
            const e = eVec.length();

            // Angular momentum vector (defines orbital plane)
            const h = new THREE.Vector3().crossVectors(position, velocity);
            const hMag = h.length();

            // Periapsis and apoapsis distances
            const rp = a * (1 - e);
            const ra = a * (1 + e);

            return {
                semiMajorAxis: a,
                eccentricity: e,
                eccentricityVector: eVec,
                angularMomentum: h,
                angularMomentumMag: hMag,
                periapsis: rp,
                apoapsis: ra,
                energy: specificEnergy
            };
        }

        function generateOrbitPoints(position, velocity, numPoints = 100) {
            const orbit = calculateOrbitFromState(position, velocity);

            // Check if orbit is valid (elliptical, not hyperbolic or parabolic)
            if (orbit.eccentricity >= 1.0 || orbit.semiMajorAxis <= 0) {
                // Hyperbolic or parabolic orbit - just simulate forward in time
                return simulateOrbitPoints(position, velocity, numPoints);
            }

            const points = [];
            const a = orbit.semiMajorAxis;
            const e = orbit.eccentricity;

            // Create a coordinate system for the orbital plane
            const eVecNorm = orbit.eccentricityVector.clone().normalize();
            const hNorm = orbit.angularMomentum.clone().normalize();
            const qVec = new THREE.Vector3().crossVectors(hNorm, eVecNorm).normalize();

            // Generate points around the ellipse
            for (let i = 0; i <= numPoints; i++) {
                const theta = (i / numPoints) * Math.PI * 2; // True anomaly
                const r = (a * (1 - e * e)) / (1 + e * Math.cos(theta));

                // Position in orbital plane coordinates
                const x = r * Math.cos(theta);
                const y = r * Math.sin(theta);

                // Transform to 3D space
                const point = new THREE.Vector3()
                    .addScaledVector(eVecNorm, x)
                    .addScaledVector(qVec, y);

                points.push(point);
            }

            return points;
        }

        function simulateOrbitPoints(position, velocity, numPoints = 100) {
            // For hyperbolic/parabolic orbits, simulate forward in time
            const points = [];
            const pos = position.clone();
            const vel = velocity.clone();
            const dt = 0.5; // Time step

            for (let i = 0; i < numPoints; i++) {
                points.push(pos.clone());

                // Simple Euler integration for visualization
                const r = pos.length();
                const force = pos.clone().normalize().multiplyScalar(-(G * planetMass) / (r * r));
                vel.add(force.multiplyScalar(dt));
                pos.add(vel.clone().multiplyScalar(dt));

                // Stop if we hit the planet
                if (r < planetRadius) break;
            }

            return points;
        }

        function createOrbitVisualization() {
            // Create orbit line
            const orbitGeometry = new THREE.BufferGeometry();
            const orbitMaterial = new THREE.LineBasicMaterial({
                color: selectedColor,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
            orbitLine.visible = false;
            scene.add(orbitLine);

            // Create apoapsis marker
            const apGeometry = new THREE.SphereGeometry(3, 16, 16);
            const apMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6666,
                transparent: true,
                opacity: 0.8
            });
            const apMarker = new THREE.Mesh(apGeometry, apMaterial);
            apMarker.visible = false;
            apMarker.position.set(0, 0, -10000); // Position far away when hidden
            scene.add(apMarker);

            // Create periapsis marker
            const peGeometry = new THREE.SphereGeometry(3, 16, 16);
            const peMaterial = new THREE.MeshBasicMaterial({
                color: 0x66ff66,
                transparent: true,
                opacity: 0.8
            });
            const peMarker = new THREE.Mesh(peGeometry, peMaterial);
            peMarker.visible = false;
            peMarker.position.set(0, 0, -10000); // Position far away when hidden
            scene.add(peMarker);

            return { orbitLine, apMarker, peMarker };
        }

        const orbitViz = createOrbitVisualization();
        predictedOrbitLine = orbitViz.orbitLine;
        apoapsisMarker = orbitViz.apMarker;
        periapsisMarker = orbitViz.peMarker;

        // Explosion particle class
        class ExplosionParticle {
            constructor(position, color) {
                this.particles = [];
                const particleCount = 100;
                
                for (let i = 0; i < particleCount; i++) {
                    const geometry = new THREE.SphereGeometry(Math.random() * 2 + 0.5, 8, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 1
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    
                    particle.position.copy(position);
                    
                    // Random velocity in all directions
                    const speed = Math.random() * 5 + 2;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    particle.velocity = new THREE.Vector3(
                        Math.sin(phi) * Math.cos(theta) * speed,
                        Math.sin(phi) * Math.sin(theta) * speed,
                        Math.cos(phi) * speed
                    );
                    
                    particle.life = 1.0;
                    particle.decay = Math.random() * 0.015 + 0.01;
                    
                    scene.add(particle);
                    this.particles.push(particle);
                }
                
                this.age = 0;
            }
            
            update() {
                this.age++;
                let allDead = true;
                
                this.particles.forEach(particle => {
                    if (particle.life > 0) {
                        allDead = false;
                        
                        // Update position
                        particle.position.add(particle.velocity.clone().multiplyScalar(0.5));
                        
                        // Apply gravity
                        const direction = particle.position.clone().normalize();
                        particle.velocity.add(direction.multiplyScalar(-0.1));
                        
                        // Fade out
                        particle.life -= particle.decay;
                        particle.material.opacity = particle.life;
                        
                        // Shrink
                        const scale = particle.life;
                        particle.scale.set(scale, scale, scale);
                    }
                });
                
                return allDead;
            }
            
            cleanup() {
                this.particles.forEach(particle => {
                    scene.remove(particle);
                    particle.geometry.dispose();
                    particle.material.dispose();
                });
            }
        }

        // Create shockwave effect
        function createShockwave(position, color) {
            const geometry = new THREE.RingGeometry(1, 2, 32);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const shockwave = new THREE.Mesh(geometry, material);
            
            // Orient the ring to face outward from planet center
            const direction = position.clone().normalize();
            shockwave.lookAt(direction);
            shockwave.position.copy(position);
            
            scene.add(shockwave);
            
            return {
                mesh: shockwave,
                scale: 1,
                maxScale: 30,
                opacity: 0.8,
                update: function() {
                    this.scale += 1.5;
                    this.opacity -= 0.02;
                    
                    this.mesh.scale.set(this.scale, this.scale, 1);
                    this.mesh.material.opacity = this.opacity;
                    
                    return this.opacity <= 0;
                },
                cleanup: function() {
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }
            };
        }

        // Create camera shake effect
        let cameraShake = { intensity: 0, duration: 0 };
        
        function triggerCameraShake(intensity, duration) {
            cameraShake.intensity = intensity;
            cameraShake.duration = duration;
        }
        
        function updateCameraShake() {
            if (cameraShake.duration > 0) {
                const shakeX = (Math.random() - 0.5) * cameraShake.intensity;
                const shakeY = (Math.random() - 0.5) * cameraShake.intensity;
                const shakeZ = (Math.random() - 0.5) * cameraShake.intensity;
                
                camera.position.x += shakeX;
                camera.position.y += shakeY;
                camera.position.z += shakeZ;
                
                cameraShake.duration--;
                cameraShake.intensity *= 0.9;
            }
        }

        // Create flash effect
        function createFlash(color) {
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.background = color;
            flash.style.opacity = '0.6';
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '9999';
            document.body.appendChild(flash);
            
            setTimeout(() => {
                flash.style.transition = 'opacity 0.3s';
                flash.style.opacity = '0';
                setTimeout(() => flash.remove(), 300);
            }, 50);
        }

        // Color selection
        let simulationSpeed = 1.0;

        // Satellite type selection
        document.querySelectorAll('.type-option').forEach(option => {
            option.addEventListener('click', (e) => {
                document.querySelectorAll('.type-option').forEach(opt => opt.classList.remove('selected'));
                e.target.classList.add('selected');
                selectedType = e.target.dataset.type;
            });
        });

        // Color selection
        document.querySelectorAll('.color-option').forEach(option => {
            option.addEventListener('click', (e) => {
                document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
                e.target.classList.add('selected');
                selectedColor = e.target.dataset.color;
            });
        });

        // UI Controls
        const sizeSlider = document.getElementById('sizeSlider');
        const heightSlider = document.getElementById('heightSlider');
        const speedSlider = document.getElementById('speedSlider');
        const addButton = document.getElementById('addSatellite');
        const clearButton = document.getElementById('clearAll');

        sizeSlider.oninput = () => document.getElementById('sizeValue').textContent = sizeSlider.value;
        heightSlider.oninput = () => document.getElementById('heightValue').textContent = heightSlider.value;
        speedSlider.oninput = () => {
            simulationSpeed = parseFloat(speedSlider.value);
            document.getElementById('speedValue').textContent = simulationSpeed.toFixed(1) + 'x';
        };

        // Time control buttons
        const playPauseBtn = document.getElementById('playPause');
        const stepForwardBtn = document.getElementById('stepForward');
        const stepBackwardBtn = document.getElementById('stepBackward');

        playPauseBtn.addEventListener('click', () => {
            isPaused = !isPaused;
            playPauseBtn.textContent = isPaused ? '‚ñ∂' : '‚ùö‚ùö';
            playPauseBtn.classList.toggle('paused', isPaused);
        });

        stepForwardBtn.addEventListener('click', () => {
            if (isPaused) {
                // Advance simulation by one frame
                updateSimulation();
            }
        });

        stepBackwardBtn.addEventListener('click', () => {
            if (isPaused) {
                // Step backward by running simulation in reverse
                updateSimulation(-1);
            }
        });

        // Create satellite models based on type
        function createSatelliteModel(size, color, type = 'standard') {
            const group = new THREE.Group();

            if (type === 'debris') {
                // Debris: irregular broken pieces, no organized structure
                const debrisColor = 0x666666; // Dull gray metal

                // Create 3-5 random irregular fragments
                const fragmentCount = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < fragmentCount; i++) {
                    const fragSize = size * (0.3 + Math.random() * 0.4);
                    const shapes = ['box', 'cylinder', 'cone', 'sphere'];
                    const shape = shapes[Math.floor(Math.random() * shapes.length)];

                    let geometry;
                    if (shape === 'box') {
                        geometry = new THREE.BoxGeometry(
                            fragSize * (0.5 + Math.random()),
                            fragSize * (0.5 + Math.random()),
                            fragSize * (0.5 + Math.random())
                        );
                    } else if (shape === 'cylinder') {
                        geometry = new THREE.CylinderGeometry(
                            fragSize * 0.3,
                            fragSize * 0.4,
                            fragSize,
                            6
                        );
                    } else if (shape === 'cone') {
                        geometry = new THREE.ConeGeometry(fragSize * 0.5, fragSize, 6);
                    } else {
                        geometry = new THREE.SphereGeometry(fragSize * 0.4, 6, 6);
                    }

                    const material = new THREE.MeshStandardMaterial({
                        color: debrisColor,
                        metalness: 0.7,
                        roughness: 0.8,
                        emissive: debrisColor,
                        emissiveIntensity: 0.1
                    });

                    const fragment = new THREE.Mesh(geometry, material);
                    fragment.position.set(
                        (Math.random() - 0.5) * size,
                        (Math.random() - 0.5) * size,
                        (Math.random() - 0.5) * size
                    );
                    fragment.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    group.add(fragment);
                }

                // Add broken solar panel fragment
                const brokenPanelGeo = new THREE.BoxGeometry(size * 1.2, size * 0.05, size * 0.6);
                const brokenPanelMat = new THREE.MeshStandardMaterial({
                    color: 0x1a3a5c,
                    metalness: 0.6,
                    roughness: 0.7
                });
                const brokenPanel = new THREE.Mesh(brokenPanelGeo, brokenPanelMat);
                brokenPanel.position.set(size * 0.5, 0, size * 0.3);
                brokenPanel.rotation.set(0.5, 0.3, 0.8);
                group.add(brokenPanel);

                group.userData = { isDebris: true };

            } else if (type === 'probe') {
                // Probe: compact, spherical core with small antenna
                const coreGeometry = new THREE.SphereGeometry(size * 0.5, 16, 16);
                const coreMaterial = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.6,
                    metalness: 0.9,
                    roughness: 0.3
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                group.add(core);

                // Small antenna
                const antennaGeometry = new THREE.CylinderGeometry(size * 0.05, size * 0.05, size * 1.2, 8);
                const antennaMaterial = new THREE.MeshStandardMaterial({
                    color: 0xcccccc,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.y = size * 0.8;
                group.add(antenna);

                // Compact solar panels
                for (let i = 0; i < 4; i++) {
                    const panelGeo = new THREE.BoxGeometry(size * 0.8, size * 0.05, size * 0.4);
                    const panelMat = new THREE.MeshStandardMaterial({
                        color: 0x2a5a8c,
                        metalness: 0.5,
                        roughness: 0.3
                    });
                    const panel = new THREE.Mesh(panelGeo, panelMat);
                    const angle = (i / 4) * Math.PI * 2;
                    panel.position.set(Math.cos(angle) * size * 0.6, 0, Math.sin(angle) * size * 0.6);
                    panel.rotation.y = angle;
                    group.add(panel);
                }

                const light = new THREE.PointLight(color, 0.5, size * 3);
                light.position.set(0, 0, 0);
                group.add(light);

                group.userData = { core, antenna };

            } else if (type === 'station') {
                // Station: large modular structure
                // Central module
                const centralGeo = new THREE.CylinderGeometry(size * 0.8, size * 0.8, size * 1.5, 8);
                const centralMat = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.3
                });
                const central = new THREE.Mesh(centralGeo, centralMat);
                central.rotation.z = Math.PI / 2;
                group.add(central);

                // Side modules
                for (let i = 0; i < 3; i++) {
                    const moduleGeo = new THREE.BoxGeometry(size * 0.6, size * 0.6, size);
                    const moduleMat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color(color).multiplyScalar(0.8),
                        emissive: color,
                        emissiveIntensity: 0.3,
                        metalness: 0.8,
                        roughness: 0.4
                    });
                    const module = new THREE.Mesh(moduleGeo, moduleMat);
                    module.position.x = (i - 1) * size * 1.2;
                    group.add(module);
                }

                // Large solar arrays
                const arrayGeo = new THREE.BoxGeometry(size * 3, size * 0.08, size * 1.8);
                const arrayMat = new THREE.MeshStandardMaterial({
                    color: 0x1a4a7f,
                    metalness: 0.6,
                    roughness: 0.2
                });

                const leftArray = new THREE.Mesh(arrayGeo, arrayMat);
                leftArray.position.set(-size * 2, 0, 0);
                group.add(leftArray);

                const rightArray = new THREE.Mesh(arrayGeo, arrayMat);
                rightArray.position.set(size * 2, 0, 0);
                group.add(rightArray);

                // Communication dish
                const dishGeo = new THREE.CylinderGeometry(size * 0.8, size * 0.4, size * 0.4, 16);
                const dishMat = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const dish = new THREE.Mesh(dishGeo, dishMat);
                dish.position.set(0, size * 1.2, 0);
                dish.rotation.x = Math.PI / 4;
                group.add(dish);

                const glow = new THREE.PointLight(color, 1, size * 5);
                group.add(glow);

                group.userData = { central, dish };

            } else {
                // Standard satellite: current design
                const bodyGeometry = new THREE.BoxGeometry(size, size * 0.7, size * 0.5);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.7,
                    metalness: 0.9,
                    roughness: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);

                const panelGeometry = new THREE.BoxGeometry(size * 2, size * 0.1, size * 1.5);
                const panelMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2a5a8c,
                    emissive: 0x1a4a7f,
                    emissiveIntensity: 0.4,
                    metalness: 0.5,
                    roughness: 0.3
                });

                const leftPanel = new THREE.Mesh(panelGeometry, panelMaterial);
                leftPanel.position.x = -size * 1.2;
                group.add(leftPanel);

                const rightPanel = new THREE.Mesh(panelGeometry, panelMaterial);
                rightPanel.position.x = size * 1.2;
                group.add(rightPanel);

                const gridGeometry = new THREE.EdgesGeometry(panelGeometry);
                const gridMaterial = new THREE.LineBasicMaterial({ color: 0x3a7abd, linewidth: 1 });
                const leftGrid = new THREE.LineSegments(gridGeometry, gridMaterial);
                leftGrid.position.copy(leftPanel.position);
                group.add(leftGrid);

                const rightGrid = new THREE.LineSegments(gridGeometry, gridMaterial);
                rightGrid.position.copy(rightPanel.position);
                group.add(rightGrid);

                const antennaGeometry = new THREE.CylinderGeometry(size * 0.1, size * 0.1, size * 1.5, 8);
                const antennaMaterial = new THREE.MeshStandardMaterial({
                    color: 0xdddddd,
                    emissive: 0xaaaaaa,
                    emissiveIntensity: 0.5,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.y = size * 1.1;
                group.add(antenna);

                const dishGeometry = new THREE.CylinderGeometry(size * 0.6, size * 0.3, size * 0.3, 16);
                const dishMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0xcccccc,
                    emissiveIntensity: 0.4,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const dish = new THREE.Mesh(dishGeometry, dishMaterial);
                dish.position.y = size * 1.8;
                dish.rotation.x = Math.PI / 6;
                group.add(dish);

                const lightGeometry = new THREE.SphereGeometry(size * 0.2, 8, 8);
                const lightMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1.0
                });
                const light = new THREE.Mesh(lightGeometry, lightMaterial);
                light.position.y = -size * 0.5;
                group.add(light);

                const glowGeometry = new THREE.SphereGeometry(size * 1.8, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.BackSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                group.add(glow);

                group.userData = {
                    leftPanel,
                    rightPanel,
                    antenna,
                    dish,
                    light,
                    body,
                    glow
                };
            }

            return group;
        }

        function createSatellite(position, velocity, size, color) {
            const mesh = createSatelliteModel(size, color, selectedType);
            mesh.position.copy(position);

            // Track launched satellite type for Mission 7
            launchedTypes.add(selectedType);

            // Create trail
            const trailGeometry = new THREE.BufferGeometry();
            const trailMaterial = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);

            const trailPositions = [];
            const maxTrailLength = 100;

            // Create persistent orbital path prediction
            const orbitPoints = generateOrbitPoints(position, velocity);
            const orbitPathGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(orbitPoints.length * 3);
            orbitPoints.forEach((point, i) => {
                positions[i * 3] = point.x;
                positions[i * 3 + 1] = point.y;
                positions[i * 3 + 2] = point.z;
            });
            orbitPathGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const orbitPathMaterial = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3,
                linewidth: 1
            });
            const orbitPath = new THREE.Line(orbitPathGeometry, orbitPathMaterial);
            scene.add(orbitPath);

            // Create apoapsis marker (red)
            const apGeometry = new THREE.SphereGeometry(2.5, 12, 12);
            const apMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4444,
                transparent: true,
                opacity: 0.8
            });
            const apoapsisMarker = new THREE.Mesh(apGeometry, apMaterial);
            scene.add(apoapsisMarker);

            // Create periapsis marker (green)
            const peGeometry = new THREE.SphereGeometry(2.5, 12, 12);
            const peMaterial = new THREE.MeshBasicMaterial({
                color: 0x44ff44,
                transparent: true,
                opacity: 0.8
            });
            const periapsisMarker = new THREE.Mesh(peGeometry, peMaterial);
            scene.add(periapsisMarker);

            // Calculate initial orbital parameters and marker positions
            const orbit = calculateOrbitFromState(position, velocity);
            if (orbit.eccentricity < 1.0 && orbit.semiMajorAxis > 0) {
                const eVecNorm = orbit.eccentricityVector.clone().normalize();
                periapsisMarker.position.copy(eVecNorm.clone().multiplyScalar(orbit.periapsis));
                apoapsisMarker.position.copy(eVecNorm.clone().multiplyScalar(-orbit.apoapsis));
                apoapsisMarker.visible = orbit.apoapsis > planetRadius;
                periapsisMarker.visible = orbit.periapsis > planetRadius;
            } else {
                apoapsisMarker.visible = false;
                periapsisMarker.visible = false;
            }

            scene.add(mesh);

            satellites.push({
                mesh,
                velocity: velocity.clone(),
                trail,
                trailPositions,
                maxTrailLength,
                size,
                orbitPath,
                apoapsisMarker,
                periapsisMarker,
                color: color,
                type: selectedType
            });

            updateCount();
        }

        // Special function for geosynchronous satellites (same appearance as standard)
        function createGeosyncSatellite(position, velocity, size, color) {
            const mesh = createSatelliteModel(size, color, 'standard');
            mesh.position.copy(position);

            // Track launched satellite type for Mission 7
            launchedTypes.add('standard');

            // Create trail (same as standard satellites)
            const trailGeometry = new THREE.BufferGeometry();
            const trailMaterial = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);

            const trailPositions = [];
            const maxTrailLength = 100;

            // Create persistent orbital path prediction
            const orbitPoints = generateOrbitPoints(position, velocity);
            const orbitPathGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(orbitPoints.length * 3);
            orbitPoints.forEach((point, i) => {
                positions[i * 3] = point.x;
                positions[i * 3 + 1] = point.y;
                positions[i * 3 + 2] = point.z;
            });
            orbitPathGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const orbitPathMaterial = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3,
                linewidth: 1
            });
            const orbitPath = new THREE.Line(orbitPathGeometry, orbitPathMaterial);
            scene.add(orbitPath);

            // Create apoapsis marker (red)
            const apGeometry = new THREE.SphereGeometry(2.5, 12, 12);
            const apMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4444,
                transparent: true,
                opacity: 0.8
            });
            const apoapsisMarker = new THREE.Mesh(apGeometry, apMaterial);
            scene.add(apoapsisMarker);

            // Create periapsis marker (green)
            const peGeometry = new THREE.SphereGeometry(2.5, 12, 12);
            const peMaterial = new THREE.MeshBasicMaterial({
                color: 0x44ff44,
                transparent: true,
                opacity: 0.8
            });
            const periapsisMarker = new THREE.Mesh(peGeometry, peMaterial);
            scene.add(periapsisMarker);

            // Calculate initial orbital parameters and marker positions
            const orbit = calculateOrbitFromState(position, velocity);
            if (orbit.eccentricity < 1.0 && orbit.semiMajorAxis > 0) {
                const eVecNorm = orbit.eccentricityVector.clone().normalize();
                periapsisMarker.position.copy(eVecNorm.clone().multiplyScalar(orbit.periapsis));
                apoapsisMarker.position.copy(eVecNorm.clone().multiplyScalar(-orbit.apoapsis));
                apoapsisMarker.visible = orbit.apoapsis > planetRadius;
                periapsisMarker.visible = orbit.periapsis > planetRadius;
            } else {
                apoapsisMarker.visible = false;
                periapsisMarker.visible = false;
            }

            scene.add(mesh);

            satellites.push({
                mesh,
                velocity: velocity.clone(),
                trail,
                trailPositions,
                maxTrailLength,
                size,
                isGeosync: true,
                type: 'standard',
                orbitPath,
                apoapsisMarker,
                periapsisMarker,
                color: color
            });

            updateCount();
        }

        addButton.addEventListener('click', () => {
            // Enter launch mode
            launchMode = true;
            document.getElementById('launchMode').classList.add('active');
            canvas.style.cursor = 'crosshair';
        });

        // Toggle 3D guides button
        const toggleGuidesButton = document.getElementById('toggleGuides');
        let guidesVisible = true;
        toggleGuidesButton.addEventListener('click', () => {
            guidesVisible = !guidesVisible;

            gridHelper.visible = guidesVisible;
            orbitRing.visible = guidesVisible;
            xAxis.visible = guidesVisible;
            yAxis.visible = guidesVisible;
            zAxis.visible = guidesVisible;

            toggleGuidesButton.textContent = guidesVisible ? 'Hide 3D Guides' : 'Show 3D Guides';
        });

        // Toggle moon button
        const toggleMoonButton = document.getElementById('toggleMoon');
        toggleMoonButton.addEventListener('click', () => {
            moonEnabled = !moonEnabled;
            moon.visible = moonEnabled;
            moonTrail.visible = moonEnabled;
            moonLabel.visible = moonEnabled;
            moonOrbitRing.visible = moonEnabled;

            toggleMoonButton.textContent = moonEnabled ? 'Remove Moon üåë' : 'Add Moon üåô';

            // Reset moon position and velocity when enabling
            if (moonEnabled) {
                moonPosition.set(moonDistance, 0, 0);
                moonVelocity.set(0, 0, Math.sqrt((G * planetMass) / moonDistance));
                moonTrailPositions.length = 0; // Clear trail
                moon.position.copy(moonPosition);

                // Zoom camera out to see the full moon orbit
                if (cameraDistance < 4000) {
                    cameraDistance = 4000;
                }
            }
        });

        // Geosynchronous satellite button
        const geoSyncButton = document.getElementById('addGeoSync');
        geoSyncButton.addEventListener('click', () => {
            // Calculate geosynchronous orbit parameters
            // For a geosynchronous orbit, orbital period = planet rotation period
            // Using T = 2œÄ‚àö(r¬≥/GM), we can solve for r
            // Assuming planet rotates once per 100 time units in our simulation

            const planetRotationPeriod = 100; // Arbitrary units matching our simulation
            const orbitalRadius = Math.pow((G * planetMass * planetRotationPeriod * planetRotationPeriod) / (4 * Math.PI * Math.PI), 1/3);

            // Random orbital inclination (angle from equatorial plane) - full range
            const inclination = (Math.random() - 0.5) * Math.PI * 1.5; // Up to ¬±135 degrees for variety

            // Random starting angle in the orbital plane
            const trueAnomaly = Math.random() * Math.PI * 2;

            // Longitude of ascending node (rotation around the Y/polar axis)
            const ascendingNode = Math.random() * Math.PI * 2;

            // Position in the orbital plane (2D, before inclination)
            const xOrbit = orbitalRadius * Math.cos(trueAnomaly);
            const zOrbit = orbitalRadius * Math.sin(trueAnomaly);

            // Apply inclination (rotate around X axis)
            const xInclined = xOrbit;
            const yInclined = zOrbit * Math.sin(inclination);
            const zInclined = zOrbit * Math.cos(inclination);

            // Apply ascending node rotation (rotate around Y axis)
            const position = new THREE.Vector3(
                xInclined * Math.cos(ascendingNode) - zInclined * Math.sin(ascendingNode),
                yInclined,
                xInclined * Math.sin(ascendingNode) + zInclined * Math.cos(ascendingNode)
            );

            // Calculate perfect circular orbital velocity
            const orbitalSpeed = Math.sqrt((G * planetMass) / orbitalRadius);

            // Velocity direction in orbital plane (perpendicular to position in 2D)
            const vxOrbit = -orbitalRadius * Math.sin(trueAnomaly);
            const vzOrbit = orbitalRadius * Math.cos(trueAnomaly);

            // Apply inclination to velocity
            const vxInclined = vxOrbit;
            const vyInclined = vzOrbit * Math.sin(inclination);
            const vzInclined = vzOrbit * Math.cos(inclination);

            // Apply ascending node rotation to velocity
            const velocity = new THREE.Vector3(
                vxInclined * Math.cos(ascendingNode) - vzInclined * Math.sin(ascendingNode),
                vyInclined,
                vxInclined * Math.sin(ascendingNode) + vzInclined * Math.cos(ascendingNode)
            );

            // Normalize and scale to correct speed
            velocity.normalize().multiplyScalar(orbitalSpeed);

            // Make geosync satellites bigger
            const geoSyncSize = 12; // Much larger than regular satellites
            createGeosyncSatellite(position, velocity, geoSyncSize, '#38ef7d');

            // Display info for the newly launched geosync satellite
            const newSatellite = satellites[satellites.length - 1];
            displaySatelliteInfo(newSatellite);
        });

        clearButton.addEventListener('click', () => {
            satellites.forEach(sat => {
                scene.remove(sat.mesh);
                scene.remove(sat.trail);
                if (sat.orbitPath) {
                    scene.remove(sat.orbitPath);
                }
                if (sat.apoapsisMarker) {
                    scene.remove(sat.apoapsisMarker);
                }
                if (sat.periapsisMarker) {
                    scene.remove(sat.periapsisMarker);
                }
            });
            satellites.length = 0;

            // Also cancel launch mode if active
            if (launchMode) {
                if (previewSatellite) {
                    disposeObject(previewSatellite);
                    scene.remove(previewSatellite);
                    previewSatellite = null;
                }
                velocityArrow.group.visible = false;
                predictedOrbitLine.visible = false;
                apoapsisMarker.visible = false;
                periapsisMarker.visible = false;
                launchStartPos = null;
                launchCurrentPos = null;
                launchMode = false;
                document.getElementById('launchMode').classList.remove('active');
                canvas.style.cursor = 'grab';
            }

            updateCount();
        });

        function updateCount() {
            document.getElementById('count').textContent = satellites.length;
        }

        // Mouse controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngle = { theta: 0, phi: 0 };
        let cameraDistance = 500;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Function to display satellite info in the panel
        function displaySatelliteInfo(satellite) {
            const infoPanel = document.getElementById('satelliteInfo');
            infoPanel.classList.add('visible');

            // Calculate orbital parameters
            const altitude = satellite.mesh.position.length() - planetRadius;
            const velocity = satellite.velocity.length();
            const orbit = calculateOrbitFromState(satellite.mesh.position, satellite.velocity);

            // Update info display
            document.getElementById('infoAltitude').textContent = altitude.toFixed(1) + ' units';
            document.getElementById('infoVelocity').textContent = velocity.toFixed(2) + ' units/s';
            document.getElementById('infoEccentricity').textContent = orbit.eccentricity.toFixed(3);

            // Calculate orbital period
            if (orbit.eccentricity < 1.0 && orbit.semiMajorAxis > 0) {
                const period = 2 * Math.PI * Math.sqrt(Math.pow(orbit.semiMajorAxis, 3) / (G * planetMass));
                document.getElementById('infoPeriod').textContent = (period / 60).toFixed(1) + ' min';
            } else {
                document.getElementById('infoPeriod').textContent = 'Escape/Collision';
            }

            // Display satellite type
            const typeNames = {
                'standard': 'Standard',
                'probe': 'Probe',
                'station': 'Station',
                'debris': 'Debris'
            };
            let typeName = typeNames[satellite.type] || 'Standard';
            if (satellite.isGeosync) {
                typeName = 'Geosync ' + typeName;
            }
            document.getElementById('infoType').textContent = typeName;

            // Show orbit status
            const statusElement = document.querySelector('.satellite-info .status');
            if (statusElement) {
                if (altitude < planetRadius * 0.1) {
                    statusElement.textContent = 'DECAYING ORBIT';
                    statusElement.className = 'status decaying';
                } else if (orbit.eccentricity >= 1.0) {
                    statusElement.textContent = 'ESCAPE TRAJECTORY';
                    statusElement.className = 'status escape';
                } else if (orbit.eccentricity < 0.15) {
                    statusElement.textContent = 'STABLE ORBIT';
                    statusElement.className = 'status stable';
                } else {
                    statusElement.textContent = 'ELLIPTICAL ORBIT';
                    statusElement.className = 'status stable';
                }
            }
        }

        function getMousePosition(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function get3DPointOnPlanet(event) {
            getMousePosition(event);
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObject(planet);
            if (intersects.length > 0) {
                return intersects[0].point;
            }
            return null;
        }

        canvas.addEventListener('mousedown', (e) => {
            previousMousePosition = { x: e.clientX, y: e.clientY };
            
            if (launchMode && e.button === 0) { // Left click in launch mode
                e.preventDefault();
                
                // Use raycasting to find a point in 3D space where user clicked
                getMousePosition(e);
                raycaster.setFromCamera(mouse, camera);
                
                // Try to intersect with planet first
                const planetIntersects = raycaster.intersectObject(planet);
                
                if (planetIntersects.length > 0) {
                    // Clicked on planet - spawn satellite slightly above surface
                    const surfacePoint = planetIntersects[0].point;
                    const normal = surfacePoint.clone().normalize();
                    launchStartPos = surfacePoint.add(normal.multiplyScalar(10)); // 10 units above surface
                } else {
                    // Clicked in empty space - create point at orbital height
                    // Cast ray and find point at desired orbital distance
                    const height = parseFloat(heightSlider.value) + planetRadius;
                    const ray = raycaster.ray;
                    
                    // Find the point along the ray that is closest to being at orbital height
                    // We want point where |point| = height
                    // Ray equation: P(t) = origin + t * direction
                    // We need to solve: |origin + t * direction|¬≤ = height¬≤
                    
                    const origin = ray.origin;
                    const dir = ray.direction;
                    
                    // Quadratic formula: a*t¬≤ + b*t + c = 0
                    const a = dir.dot(dir);
                    const b = 2 * origin.dot(dir);
                    const c = origin.dot(origin) - height * height;
                    
                    const discriminant = b * b - 4 * a * c;
                    
                    if (discriminant >= 0) {
                        // Take the closer intersection point
                        const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
                        const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);
                        const t = t1 > 0 ? t1 : t2;
                        
                        launchStartPos = origin.clone().add(dir.clone().multiplyScalar(t));
                    } else {
                        // Fallback: use point along ray at fixed distance
                        launchStartPos = origin.clone().add(dir.clone().multiplyScalar(height));
                    }
                }
                
                isDragging = true;
                launchCurrentPos = launchStartPos.clone();
                
                // Create preview satellite at the actual click point
                const size = parseFloat(sizeSlider.value);
                previewSatellite = createSatelliteModel(size, selectedColor, selectedType);
                previewSatellite.position.copy(launchStartPos);
                previewSatellite.traverse((child) => {
                    if (child.material) {
                        child.material = child.material.clone();
                        child.material.transparent = true;
                        child.material.opacity = 0.7;
                    }
                });
                scene.add(previewSatellite);
            } else if (!launchMode && (e.button === 0 || e.button === 2)) { // Left or right click when not in launch mode
                isDragging = true;
                e.preventDefault(); // Prevent context menu on right click
            }
        });

        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (launchMode && launchStartPos && isDragging) {
                e.preventDefault();
                
                const deltaX = (e.clientX - previousMousePosition.x);
                const deltaY = (e.clientY - previousMousePosition.y);
                
                // Convert screen delta to 3D offset relative to camera
                const right = new THREE.Vector3();
                const up = new THREE.Vector3();
                camera.matrix.extractBasis(right, up, new THREE.Vector3());
                
                launchCurrentPos = launchStartPos.clone()
                    .add(right.multiplyScalar(deltaX * 0.5))
                    .add(up.multiplyScalar(-deltaY * 0.5));
                
                // Calculate and display velocity vector
                const velocityVector = launchCurrentPos.clone().sub(launchStartPos);
                const length = velocityVector.length();

                if (length > 0.5) {
                    velocityArrow.group.visible = true;

                    // Update arrow colors
                    velocityArrow.material.color.set(selectedColor);
                    velocityArrow.headMaterial.color.set(selectedColor);
                    velocityArrow.tipMaterial.color.set(selectedColor);

                    // Position arrow at satellite
                    velocityArrow.group.position.copy(launchStartPos);

                    // Scale shaft based on vector length
                    const arrowLength = Math.min(length * 2, 100);
                    velocityArrow.shaft.scale.y = arrowLength;
                    velocityArrow.shaft.position.y = arrowLength / 2;

                    // Position head at end
                    velocityArrow.head.position.y = arrowLength;

                    // Position tip sphere at the very end
                    velocityArrow.tip.position.y = arrowLength + 4;

                    // Pulse the tip sphere based on velocity magnitude
                    const pulseScale = 1 + Math.sin(Date.now() * 0.01) * 0.3;
                    velocityArrow.tip.scale.set(pulseScale, pulseScale, pulseScale);

                    // Orient arrow in direction of velocity
                    const direction = velocityVector.clone().normalize();
                    const axis = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, direction);
                    velocityArrow.group.setRotationFromQuaternion(quaternion);

                    // Calculate and display predicted orbit
                    const velocity = velocityVector.clone().multiplyScalar(2); // Same scale factor as launch
                    const orbitPoints = generateOrbitPoints(launchStartPos, velocity);

                    // Update orbit line
                    const positions = new Float32Array(orbitPoints.length * 3);
                    orbitPoints.forEach((point, i) => {
                        positions[i * 3] = point.x;
                        positions[i * 3 + 1] = point.y;
                        positions[i * 3 + 2] = point.z;
                    });

                    predictedOrbitLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    predictedOrbitLine.geometry.attributes.position.needsUpdate = true;
                    predictedOrbitLine.material.color.set(selectedColor);
                    predictedOrbitLine.visible = true;

                    // Calculate and show apoapsis/periapsis
                    const orbit = calculateOrbitFromState(launchStartPos, velocity);

                    if (orbit.eccentricity < 1.0 && orbit.semiMajorAxis > 0) {
                        // Valid elliptical orbit
                        const eVecNorm = orbit.eccentricityVector.clone().normalize();

                        // Periapsis (closest point) - eccentricity vector points toward periapsis
                        const pePosition = eVecNorm.clone().multiplyScalar(orbit.periapsis);
                        periapsisMarker.position.copy(pePosition);
                        periapsisMarker.visible = orbit.periapsis > planetRadius;

                        // Apoapsis (furthest point) - opposite direction of eccentricity vector
                        const apPosition = eVecNorm.clone().multiplyScalar(-orbit.apoapsis);
                        apoapsisMarker.position.copy(apPosition);
                        apoapsisMarker.visible = orbit.apoapsis > planetRadius;
                    } else {
                        // Not a closed orbit
                        apoapsisMarker.visible = false;
                        periapsisMarker.visible = false;
                    }
                } else {
                    predictedOrbitLine.visible = false;
                    apoapsisMarker.visible = false;
                    periapsisMarker.visible = false;
                }
            } else if (isDragging && !launchMode) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                cameraAngle.theta += deltaX * 0.005;
                cameraAngle.phi += deltaY * 0.005;
                cameraAngle.phi = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraAngle.phi));

                previousMousePosition = { x: e.clientX, y: e.clientY };
            }

            // Check for hover over satellites (when not in launch mode and not dragging)
            if (!launchMode && !isDragging) {
                getMousePosition(e);
                raycaster.setFromCamera(mouse, camera);

                // Check intersections with satellite meshes
                const satelliteMeshes = satellites.map(sat => sat.mesh);
                const intersects = raycaster.intersectObjects(satelliteMeshes, true);

                if (intersects.length > 0) {
                    // Find which satellite was hit
                    const hitMesh = intersects[0].object;
                    const satellite = satellites.find(sat =>
                        sat.mesh === hitMesh || sat.mesh.children.includes(hitMesh) || isChildOfMesh(hitMesh, sat.mesh)
                    );

                    if (satellite) {
                        // Display satellite info using shared function
                        displaySatelliteInfo(satellite);
                        canvas.style.cursor = 'pointer';
                    }
                } else {
                    // No satellite hovered
                    document.getElementById('satelliteInfo').classList.remove('visible');
                    if (!launchMode) {
                        canvas.style.cursor = 'grab';
                    }
                }
            }
        });

        // Helper function to check if a mesh is a child of another mesh
        function isChildOfMesh(child, parent) {
            let current = child.parent;
            while (current) {
                if (current === parent) return true;
                current = current.parent;
            }
            return false;
        }

        canvas.addEventListener('mouseup', (e) => {
            if (launchMode && launchStartPos && launchCurrentPos && isDragging && e.button === 0) {
                e.preventDefault();
                
                // Calculate final velocity
                const velocityVector = launchCurrentPos.clone().sub(launchStartPos);
                
                if (velocityVector.length() > 0.5) {
                    const velocity = velocityVector.multiplyScalar(2); // Scale factor for velocity

                    // Create satellite with this velocity
                    const size = parseFloat(sizeSlider.value);
                    createSatellite(launchStartPos, velocity, size, selectedColor);

                    // Display info for the newly launched satellite
                    const newSatellite = satellites[satellites.length - 1];
                    displaySatelliteInfo(newSatellite);
                }

                // Clean up
                if (previewSatellite) {
                    disposeObject(previewSatellite);
                    scene.remove(previewSatellite);
                    previewSatellite = null;
                }
                velocityArrow.group.visible = false;
                predictedOrbitLine.visible = false;
                apoapsisMarker.visible = false;
                periapsisMarker.visible = false;
                launchStartPos = null;
                launchCurrentPos = null;
                isDragging = false;

                // Exit launch mode
                launchMode = false;
                document.getElementById('launchMode').classList.remove('active');
                canvas.style.cursor = 'grab';
            } else {
                isDragging = false;
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            // ESC key to cancel launch mode
            if (e.key === 'Escape' && launchMode) {
                // Cancel launch mode
                if (previewSatellite) {
                    disposeObject(previewSatellite);
                    scene.remove(previewSatellite);
                    previewSatellite = null;
                }
                velocityArrow.group.visible = false;
                predictedOrbitLine.visible = false;
                apoapsisMarker.visible = false;
                periapsisMarker.visible = false;
                launchStartPos = null;
                launchCurrentPos = null;
                launchMode = false;
                document.getElementById('launchMode').classList.remove('active');
                canvas.style.cursor = 'grab';
            }

            // Spacebar to pause/unpause simulation
            if (e.key === ' ' || e.code === 'Space') {
                e.preventDefault(); // Prevent page scroll
                isPaused = !isPaused;
                playPauseBtn.textContent = isPaused ? '‚ñ∂' : '‚ùö‚ùö';
                playPauseBtn.classList.toggle('paused', isPaused);
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.5;
            cameraDistance = Math.max(150, Math.min(5000, cameraDistance));
        });

        // Simulation update function (extracted for pause/step control)
        function updateSimulation(direction = 1) {
            // direction: 1 = forward, -1 = backward
            time += 0.01 * simulationSpeed * direction;

            // Update planet shader
            planetMaterial.uniforms.time.value = time;
            cloudMaterial.uniforms.time.value = time;

            // Rotate planet slowly
            planet.rotation.y += 0.001 * simulationSpeed * direction;

            // Rotate clouds slightly faster for parallax effect
            clouds.rotation.y += 0.0015 * simulationSpeed * direction;

            atmosphere.rotation.y += 0.001 * simulationSpeed * direction;

            // Update satellites
            const dt = 0.016 * simulationSpeed * direction; // Apply simulation speed and direction to time delta
            satellites.forEach((sat, index) => {
                const position = sat.mesh.position;
                const distance = position.length();

                // Check collision with planet
                if (distance < planetRadius + sat.size) {
                    // DRAMATIC EXPLOSION!
                    const impactColor = new THREE.Color(sat.color);

                    // Create explosion particles
                    const explosion = new ExplosionParticle(position.clone(), impactColor);
                    explosions.push(explosion);

                    // Create shockwave
                    const shockwave = createShockwave(position.clone(), impactColor);
                    explosions.push(shockwave);

                    // Camera shake based on satellite size
                    triggerCameraShake(sat.size * 0.5, 20);

                    // Screen flash
                    createFlash(`rgba(${parseInt(impactColor.getHexString().slice(0,2), 16)}, ${parseInt(impactColor.getHexString().slice(2,4), 16)}, ${parseInt(impactColor.getHexString().slice(4,6), 16)}, 0.3)`);

                    // Add temporary bright light at impact
                    const impactLight = new THREE.PointLight(impactColor, 3, 300);
                    impactLight.position.copy(position);
                    scene.add(impactLight);
                    setTimeout(() => scene.remove(impactLight), 200);

                    // Clean up satellite
                    scene.remove(sat.mesh);
                    scene.remove(sat.trail);
                    if (sat.orbitPath) {
                        scene.remove(sat.orbitPath);
                    }
                    if (sat.apoapsisMarker) {
                        scene.remove(sat.apoapsisMarker);
                    }
                    if (sat.periapsisMarker) {
                        scene.remove(sat.periapsisMarker);
                    }
                    satellites.splice(index, 1);
                    updateCount();
                    return;
                }

                // Calculate gravitational force from planet
                const directionVec = position.clone().normalize();
                const forceMagnitude = (G * planetMass) / (distance * distance);
                const force = directionVec.multiplyScalar(-forceMagnitude);

                // Add gravitational force from moon (if enabled)
                if (moonEnabled) {
                    const moonToSat = position.clone().sub(moonPosition);
                    const moonDistance = moonToSat.length();
                    if (moonDistance > 0.1) { // Avoid singularity
                        const moonDirection = moonToSat.normalize();
                        const moonForceMagnitude = (G * moonMass) / (moonDistance * moonDistance);
                        const moonForce = moonDirection.multiplyScalar(-moonForceMagnitude);
                        force.add(moonForce);
                    }
                }

                // Update velocity and position
                sat.velocity.add(force.multiplyScalar(dt));
                sat.mesh.position.add(sat.velocity.clone().multiplyScalar(dt));

                // Update trail
                sat.trailPositions.push(sat.mesh.position.clone());
                if (sat.trailPositions.length > sat.maxTrailLength) {
                    sat.trailPositions.shift();
                }

                const positions = new Float32Array(sat.trailPositions.length * 3);
                sat.trailPositions.forEach((pos, i) => {
                    positions[i * 3] = pos.x;
                    positions[i * 3 + 1] = pos.y;
                    positions[i * 3 + 2] = pos.z;
                });

                sat.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                sat.trail.geometry.attributes.position.needsUpdate = true;

                // Rotate satellite body slowly
                if (sat.mesh.userData.isDebris) {
                    // Debris tumbles erratically on all axes
                    sat.mesh.rotation.x += 0.05 * simulationSpeed * direction;
                    sat.mesh.rotation.y += 0.07 * simulationSpeed * direction;
                    sat.mesh.rotation.z += 0.03 * simulationSpeed * direction;
                } else {
                    sat.mesh.rotation.y += 0.01 * simulationSpeed * direction;
                }

                // Animate satellite components
                if (sat.mesh.userData) {
                    // Pulse communication light
                    if (sat.mesh.userData.light) {
                        const pulse = Math.sin(time * 5 + sat.mesh.position.x) * 0.3 + 0.7;
                        sat.mesh.userData.light.material.opacity = pulse;
                    }

                    // Gently oscillate dish
                    if (sat.mesh.userData.dish) {
                        sat.mesh.userData.dish.rotation.x = Math.PI / 6 + Math.sin(time * 0.5) * 0.1;
                    }
                }
            });

            // Update moon orbit (if enabled)
            if (moonEnabled) {
                // Moon orbits the planet
                const moonDist = moonPosition.length();
                const moonDir = moonPosition.clone().normalize();
                const moonForceMag = (G * planetMass) / (moonDist * moonDist);
                const moonForce = moonDir.multiplyScalar(-moonForceMag);

                // Update moon velocity and position
                moonVelocity.add(moonForce.multiplyScalar(dt));
                moonPosition.add(moonVelocity.clone().multiplyScalar(dt));
                moon.position.copy(moonPosition);

                // Update moon trail
                moonTrailPositions.push(moonPosition.clone());
                if (moonTrailPositions.length > maxMoonTrailLength) {
                    moonTrailPositions.shift();
                }

                const moonPositions = new Float32Array(moonTrailPositions.length * 3);
                moonTrailPositions.forEach((pos, i) => {
                    moonPositions[i * 3] = pos.x;
                    moonPositions[i * 3 + 1] = pos.y;
                    moonPositions[i * 3 + 2] = pos.z;
                });

                moonTrail.geometry.setAttribute('position', new THREE.BufferAttribute(moonPositions, 3));
                moonTrail.geometry.attributes.position.needsUpdate = true;

                // Rotate moon slowly
                moon.rotation.y += 0.005 * simulationSpeed * direction;
            }

            // Update explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                if (explosions[i].update()) {
                    explosions[i].cleanup();
                    explosions.splice(i, 1);
                }
            }

            // Slowly rotate stars
            stars.rotation.y += 0.0001 * simulationSpeed * direction;
        }

        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);

            // Only update simulation if not paused
            if (!isPaused) {
                updateSimulation();
            }

            // Update mission progress (always update even when paused)
            updateMission();

            // Update camera position (always update even when paused)
            camera.position.x = cameraDistance * Math.sin(cameraAngle.theta) * Math.cos(cameraAngle.phi);
            camera.position.y = cameraDistance * Math.sin(cameraAngle.phi);
            camera.position.z = cameraDistance * Math.cos(cameraAngle.theta) * Math.cos(cameraAngle.phi);
            camera.lookAt(0, 0, 0);

            // Update camera shake (always update)
            updateCameraShake();

            // Render the scene
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

        // Add a couple of starting satellites with circular orbits
        const pos1 = new THREE.Vector3(150, 0, 0);
        const vel1 = new THREE.Vector3(0, 0, Math.sqrt((G * planetMass) / 150));
        createSatellite(pos1, vel1, 4, '#6eb5ff');

        const pos2 = new THREE.Vector3(0, 0, 200);
        const vel2 = new THREE.Vector3(Math.sqrt((G * planetMass) / 200), 0, 0);
        createSatellite(pos2, vel2, 6, '#ff6eb5');

        // Initialize first mission
        loadMission(0);

        // Wire up Next Mission button
        document.getElementById('nextMissionBtn').addEventListener('click', () => {
            loadMission(currentMissionIndex + 1);
        });

        // Mission panel toggle functionality
        let missionsVisible = true;
        const missionPanel = document.getElementById('missionPanel');
        const missionToggleBtn = document.getElementById('missionToggleBtn');
        const showMissionsBtn = document.getElementById('showMissionsBtn');

        // Hide missions button (X on the panel)
        missionToggleBtn.addEventListener('click', () => {
            missionsVisible = false;
            missionPanel.classList.add('hidden');
            showMissionsBtn.style.display = 'block';
        });

        // Show missions button (in controls)
        showMissionsBtn.addEventListener('click', () => {
            missionsVisible = true;
            missionPanel.classList.remove('hidden');
            showMissionsBtn.style.display = 'none';
        });
    </script>
</body>
</html>